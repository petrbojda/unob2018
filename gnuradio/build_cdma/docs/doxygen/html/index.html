<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GNU Radio&#39;s CDMA Package: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio&#39;s CDMA Package
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">GNU Radio's CDMA Package Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>This CDMA module is intended to build a parameterized CDMA physical layer. Users can set spreading, modulation, framing parameters, etc in a global parameter file "python/cdma_paramters.py". The basic structure of this CDMA system is as follows:</p>
<p>Transmission is done in frames of length "symbols_per_frame". Each frame consists of two superimposed orthogonal physical channels: the training channel and the data channel. The training channel consists of a training sequence "training" of length "symbols_per_frame" that is spread using the same spreading code of "chips_per_symbol" chips for each symbol. For simplicity the training sequence is modulated using antipodal modulation (but this can be readily changed by the user). The data channel consists of "symbols_per_frame" data symbols that is spread using a spreading code of "chips_per_symbol" chips for each symbol which is orthogonal to the training code. The data symbols are composed of "symbols_per_header" header symbols and "coded_payload_symbols_per_frame" coded payload symbols modulated with (possibly different) modulation schemes. Further, the coded payload symbols are produced by CRC encoding "coded_payload_bytes_per_frame" with a user defined CRC code. The user can set the percentage of power used for training and data ("training_percent").</p>
<p>At the receiver, the core part is a timing/frequency acquisition engine which consists of a user-defined "n_filt" number of xlating matched-filters matched to training sequence at different frequencies (similarly user defined in the vector "freqs"). The output of the acquisition block is a stream of flags indicating the estimated begining of the frame and a stream of frequencies indicating the estimated frequency offset. The received samples are then frequency corrected, and "chopped" according to the generated flags. The samples are then input to two matched-filters, each matched to the training spreading pulse, and the data spreading pulse respectively, thus resulting in the despread training and data sequences. The training symbols are used to perform phase estimation using a symbol-spaced PLL. The phase estimates are used to derotate the data symbols which are then demodulated, using two constellation decoders corresponding to header and payload modulations, respectively. Finally, the header symbols are parsed and the data symbols are CRC decoded.</p>
<p>In addition, the despread, phase-corrected training samples are input to an SNR estimator (amp_var_est_hier) which estimates the signal amplitude and noise variance by method of moments. The estimated training energy and noise variance are dynamically detected by two probes to form an SNR estimate. This SNR estimate is used in the receiver to automatically switch between acquisition mode and training mode.</p>
<p>This CDMA Module contains three C++ blocks and three python blocks. The documentations of C++ blocks are shown in subsequent class documentation, and the documentations of python blocks are written in python files.</p>
<h1><a class="anchor" id="hier"></a>
GRC Hierarchical Blocks</h1>
<p>The documentations of some hierarchical blocks are as follows.</p>
<h2><a class="anchor" id="chopper_correlator"></a>
chopper_correlator</h2>
<p>The chopper_correlator is used in the CDMA receiver where two orthogonal training and data channels are superimposed.</p>
<p>The chopper part aligns the input samples with the flags and extracts the samples relevant to a single frame. It has two matched-filters matched to the training pulse and data pulse respectively. So it has two correlation outputs: decimated_training and decimated_data. The phase offset is extracted from the decimated training output by multiplying by the known training sequence, and driving a PLL. This phase offest is used to correct the output of training and data. The corrected training is multiplied by the training sequence to get the unmodulated training output.</p>
<p>The flow graph of chopper_correlator is shown in Fig 1.</p>
<p>The chopper_correlator has two inputs:</p>
<ul>
<li>in: a received data stream after frequency offset correction.</li>
<li>flag: a flag stream indicating the begining of a frame.</li>
</ul>
<p>The chopper_correlator has two outputs:</p>
<ul>
<li>unmodulated_out_training: a stream of the unmodulated output which is the product of the corrected output and the known training sequence.</li>
<li>corrected_data_out: a stream of the corrected data output which is the product of the estimated phase offset and the decimated correlation data output.</li>
</ul>
<p>The chopper_correlator has five parameters:</p>
<ul>
<li>N: the length of the input data frame.</li>
<li>ts: the training sequence given at the transmitter</li>
<li>Q: the decimating factor. In DSSS system, it's the spreading factor.</li>
<li>pulse: the pulse for the training stream.</li>
<li>pulse_data: the pulse for the data stream.</li>
</ul>
<div class="image">
<img src="chopper_correlator.jpeg" alt="chopper_correlator.jpeg"/>
<div class="caption">
Fig 1. Core elements of the chopper_correlator</div></div>
<h2><a class="anchor" id="amp_var_est_hier"></a>
amp_var_est_hier</h2>
<p>The amp_var_est_hier is performing amplitude and noise variance estimation of a constant sequence by means of moments shown in Fig 2.</p>
<p>Assume the input to be: <img class="formulaInl" alt="$ y=\sqrt E_s \exp(j \phi) +n = (\sqrt E_s \cos(\phi)+n_1)+j(\sqrt E_s \sin(\phi)+n_2) $" src="form_0.png"/> with components <img class="formulaInl" alt="$n_1$" src="form_1.png"/> and <img class="formulaInl" alt="$n_2$" src="form_2.png"/> having zero mean and variance <img class="formulaInl" alt="$\sigma^2$" src="form_3.png"/>.</p>
<p>By taking the squared mean of the real part, we get <img class="formulaInl" alt="$ A=E^2(\sqrt E_s \cos(\phi)+n_1)= E_s \cos^2(\phi) $" src="form_4.png"/>, which is the squared amplitude estimate that this block produces.</p>
<p>The mean squared value of the same quantity is <img class="formulaInl" alt="$ B = E[ ( \sqrt E_s \cos(\phi)+n_1)^2] = E_s \cos^2(\phi)+\sigma^2 $" src="form_5.png"/>, and the noise variance estimate is formed as <img class="formulaInl" alt="$ B^2-A = \sigma^2 $" src="form_6.png"/>.</p>
<p>Note that the although the input to this block is the PLL output, ie, a phase corrected signal, any uncorrected phase rotation will affect the estimated SNR and will thus trigger re-aqcquisition.</p>
<p>The block has one input:</p>
<ul>
<li>in: input noisy data stream. In the CDMA system, it's the output of the unmodulated and phase-corrected training output.</li>
</ul>
<p>The chopper_correlator has two inputs:</p>
<ul>
<li>amp2: estimated signal energy.</li>
<li>noise_var: estimated noise variance.</li>
</ul>
<div class="image">
<img src="amp_var_est_hier.jpeg" alt="amp_var_est_hier.jpeg"/>
<div class="caption">
Fig 2. Core elements of amp_var_est_hier</div></div>
<h2><a class="anchor" id="cdma_tx_hier"></a>
cdma_tx_hier</h2>
<p>This is the cdma transmitter hier block.</p>
<p>It has one input and one output. In the CDMA system, the input is payload bytes (0 to 255 per byte) and then is CRC coded. Then headers bits are generated from the coded payload streams and then BPSK modulated. The coded payload bytes are repacked to symbols representing m bits and then the symbols are modulated using a <img class="formulaInl" alt="$2^m$" src="form_7.png"/>-ary modulation. Then the modulated header and payload streams are muxed. The muxed payload stream is spread by "pulse_data" and scaled appropriately. On the other hand, the training symbols are spread by "pulse_training" (orthogonal to "pulse_data") and scaled accordingly. Then the two channels are superimposed to form a frame to be transmitted.</p>
<p>The flow graph of cdma_tx_hier is shown in Fig 3.</p>
<div class="image">
<img src="cdma_tx_hier.jpeg" alt="cdma_tx_hier.jpeg"/>
<div class="caption">
Fig 3. Core elements of cdma_tx_hier</div></div>
<h2><a class="anchor" id="cdma_rx_hier"></a>
cdma_rx_hier</h2>
<p>This is the cdma receiver hier block. How the receiver works is roughly described in the Introduction part. Some details are discussed in the following.</p>
<p>First, let's look at the complexity reduction of Tracking mode. From the complexity discussion in /python/kronecker_filter.py we know, the complexity of the freq_timing_estimator is roughly n_filt*(len(sequence2)+len(sequence1)). In Acquisition mode, sequence1 is the training sequence and the sequence2 is the training spreading pulse while in Training mode, sequence1 and sequence2 are all set to zero. Therefore it results in considerable complexity reduction in Tracking mode. The mode selection is controled by the acq parameter. When acq=1, Aquisition mode is selected and vice versa.</p>
<p>The cdma_rx_hier has five outputs:</p>
<ul>
<li>N0_est: estimated noisei power spectral density level <img class="formulaInl" alt="$ N_0 $" src="form_8.png"/>.</li>
<li>Es_est: estimated symbol energy.</li>
<li>decoded_payload: the decoded payload which represents <img class="formulaInl" alt="$m$" src="form_9.png"/> bits per byte.</li>
<li>decoded_header: the decoded header message.</li>
<li>acq_frequency: the acquisition frequency (for display purposes)</li>
</ul>
<h1><a class="anchor" id="app"></a>
Applications</h1>
<p>There are several applications available in this module.</p>
<h2><a class="anchor" id="cdma_txrx"></a>
cdma_txrx</h2>
<p>The cdma_txrx is a fully working CDMA system.</p>
<p>The source payload is a repeated random vector. The cdma_tx_hier block produces the CDMA frames. A Channel Model is used to simulate the AWGN channel with frequency offset and time delays. At the receiver, the cdma_rx_hier takes the received samples as input. There is a slider for dynamic change of acquisition threshold. Two choosers are used to control the mode. One is Manual/Auto chooser and the other is the Tracking/Aquisition chooser when Mannual is selected at the first chooser. Three probes are used to dynamically observe the outputs of the cdma_rx_hier. One probe obeserves the estimated symbol energy (Es_est), and another probe observes the estimated spectrum noise density (N0_est). Then the EsN0_est is computed dynamically from these two observations. Aqusition frequency is observed by the last probe and displayed. Finally there is a slider for selecting the minimum data EsN0 threshold that will trigger acquisition mode.</p>
<p>Observe that in this pure grc application, when the system enters tracking mode, essentially two things happen: First, the taps of all n_filt filters in the freq_timing_estimator block are set to (0,). This implies that this block does not produce any meaningful outputs, which is fine since we are in tracking mode. Alternatively, we could lock the graph, disconnect all these blocks and reconnect them back in acquisition mode. However, due to the yet unresolved bug in lock/unlock (see Bug #598) this method seemed like a good compromise (it is possible that calling all these blocks (even with 0 taps) results in significant performance loss). Second, the block flag_gen automatically generates flags at the correct period and at the offset set by the last flag generated at acquisition mode. This is not exactlt "tracking", but essentially maintaining the most recent acquisition parameters. This can be a nice "to do" item.</p>
<h2><a class="anchor" id="Split"></a>
cdma_tx and cdma_rx</h2>
<p>This splits the previous application into cdma_tx and cdma_rx for operation as separate Tx and Rx (possibly using two different hosts and USRPs).</p>
<h2><a class="anchor" id="freq_timing_acq_test"></a>
freq_timing_acq_test</h2>
<p>The application frequency/timing aquisition test is a simple system to test the frequency/timing aquisition. The structure of the system is similar to the cdma_tx_hier and cdma_rx_hier. But only training sequence is transmitted in the system. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
